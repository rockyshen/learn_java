Java中各种类的说明：[Java 17 API docs](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/module-summary.html)
中文版API说明：[Java 6 API 中文文档](https://tool.oschina.net/apidocs/apidoc?api=jdk-zh)

工程Project  ->  模块module  ->  包package  ->  类class

OneDrive-个人/文档/02-学习/Learn_Java_Mosh/java_标准包_类_关系图.excalidraw
# Excalidraw规范
  [Excalidraw绘图](https://excalidraw.com/)
  色彩标识，同IDEA
- 黑色：package，包
- 蓝色：Class类
- 绿色：interface接口
- 蓝色虚线：pom类型的module
- 蓝色实线：module，微服务模块（边上的黑色，导入的依赖，可以看到上下依赖传递关系）


project.module.package.Class
	一个工程，包含多个module（商品模块、用户模块等）
	一个模块，包含多个包（utils包、common包等等）
	一个包，包含多个类
![](https://raw.githubusercontent.com/rockyshen/blog-img/master/IMG_1457.PNG)

类的全限定符，也就是：包.类

什么不用加Module呢？因为Module下的结构是固定的，也就是`src/java/main`和resource，所以打成Jar包后都一样。
在模块的 src/main/java 目录和 src/main/resources 目录下同时存在相同的包名（例如 com.atguigu）的类或资源文件，这些文件会被视为同一个模块下的内容，会被打包在同一个模块的命名空间中。这意味着该模块的类加载器会将这些类文件合并成一个统一的命名空间，程序可以访问这些类而不必明确指定它们来自哪个目录。

联想到Python也有自己的内置库 

在 Java 中，`import` 语句用于引入其他包中的类或接口
必须精确到类或接口的名称，即需要指定完整的类或接口名
除了导入单个类或接口外，Java 还支持通配符导入，通过使用 `import com.example.package.*;` 这样的语法，可以导入某个包下的所有类和接口。

在 Python 中，`import` 语句用于引入其他模块中的功能，可以是单个功能、类或整个模块。
不需要精确到模块中的具体功能，你可以通过 `import module_name` 来导入整个模块，在代码中使用时需要带上模块名。
Python 支持从模块中导入特定的功能或类，通过 `from module_name import function_name` 或 `from module_name import class_name` 这样的语法可以选择性地导入模块中的特定功能或类。
在 Python 中，还可以使用 `as` 关键字给导入的模块、功能、类起个别名，这对于避免命名冲突或简化代码很有用。

从这里就能看出，Java是严格的面向对象编程，所有方法必须依托于类。而Python并非严格的面向对象编程，一个包里有很多方法，直接用，不用依托于类！
Java：[[标准包.类]]
Python：[[标准库.内置函数]]！

```
├── module
	├── package1     // 外出包，可被导入
	……
	├── package2     // 私有包，仅供module内部使用
	├── 其他资源文件 
```

```lang
├── java.base      // module，模块
	├── java.lang     // lang包
		├── Object类
			├── Number类
				├── Byte、Interger、Float、Double、Long类 
				    //将基本类型中数字相关的包装成类
			├── Character类    //将基本类型中的char包装成类				    
			├── String类
			├── Boolean类
		├── Math类
		├── Runtime类
			├── getRuntime.availableProcessors
		├── System类
		├── Throwable类
		├── Iterator接口      // 实现遍历功能的接口，是util包下Collection接口的父
		├── Comparable接口
		├── Thread类         // 并发编程相关-线程类
		├── Runable接口      // 接口可以实现在thread上运行，跑起来
```

^2a7835

```util
	├── java.util       // util工具包
		├── Collection接口    // 集合框架的根接口,跨包继承lang包下的Iterable接口
			├── List接口
				├── ArrayList类     // 实现List接口，数组
				├── LinkedList类    // 实现List接口，链表
			├── Set接口
			├── Queue接口
		├── Collections类    //提供操作集合Collection的方法，集合框架的成员
		├── Arrays实用类        // 提供操作数组的静态方法，是集合框架的成员
		├── Scanner类
		├── Random类
		├── Comparator接口
		├── function包            // 声明的函数式接口
		├── Stream流
			├── Collector接口     //用于stream中的数据收集
			├── Collectors实用类  //提供收集器的静态方法
		├── concurrent包          // Java并发编程，JUC
			├── locks.Lock接口      // 线程安全相关，类似synchronized关键字	
```

^887a3e

```

	├── java.text      // text包，处理格式化相关
		├──	NumberFormat类

```

```
// 以下不常用
	├── java.math      //注意，区别于lang包中的Math类，任何精度的计算底层实现
	├── java.io
		├── File类       // 读取、存储文件数据，写入内存  File类及IO流 
	├── java.net
	├── java.security
	├── java.time
	├── java.sql         // JDBC
	├── javax.sql        // JDBC		

```

# java.lang包
java.lang包是java语言的核心类包，代表：language（语言）。
![[#^2a7835]]

## Object类
**==所有类的祖宗类！==**
是所有类的父类，联想到Python中的[[类#基类]]！在java中如果一个类没有显式指定它的父类，那么默认继承自Object类。NB啊

思考：为什么同步代码块时，任何一个对象都能传进去呢？
[[Java_03_高级特性#同步代码块]]
![[Java_03_高级特性#^b9a4bb]]
### 通用方法
由于Object类是所有类的父类，因此Object类的方法，可以被所有类共同使用。
一个抽象概念的类，理应具备以下方法：
	可以被比较
	可以判断是否相等
	可以克隆
	可以基于实例获取类名
#### equals( )
Object类原生的equals方法，很鸡肋，就是检测两个对象的引用是否相同！
> `==`比较操作符，比较的是引用，Object类下的原始equals方法相同！

很鸡肋，因为基于Person类，new出来两个完全相同信息的实例对象p1 和 p2，调用equals还是false；因为引用的是堆空间两个实例对象。
因此，很多类都会覆盖equals方法，以便根据实际需求，针对对象的指定Field的值进行比较。

重写equal()方法需要注意的点：
1、传递的参数固定且默认是`Object obj`，不然@Override注解器将编译错误！
2、需要在方法内部，进行Downcasting
3、==重要==：自定义的类中，equals()和hashcode()必须一起重写，可以利用cmd+n，自动生成重写的equals() 和 hashcode()。

Q：为什么重写equals方法时，必须要重写hashCode方法？
A：hashCode 和 equals 两个方法是用来==协同判断==两个对象是否相等的！如果不重写hashcode在操作集合类时，就会出现问题：
情况1：对象如果需要放入HashMap时，需要判断HashMap中这个对象是否存在，是基于这个对象中的hashcode判断的。如果我们只重写equals方法，只判断值相同，可能存在hashCode不同，就无法和HashMap类一起配合工作了！
情况2：我们都知道Set集合的特点是不存在重复元素，还是上面Person类和p1、p2实例对象的例子，加入我们自定义的Person类只重写了equals方法（我们指定name=name；age=age），不重写hashcode方法，当我们加入Set集合的时候，两个都会加进去，不会去重！失去了Set集合的意义！
一般情况下，重写hashcode都是基于Field重写生成hash值。 ^bfa335
![[数据结构-哈希表#^a4191a]] ^b940bd

对象内存布局中对象头 -> 记录了这个对象的hashcode [[JVM#对象标记 Mark Word]]
![[JVM#^e112fb]]
```
public class MyString {  
	// Field
    private String value;  

	// 构造函数
    public MyString(String value) {  
        this.value = value;  
    }  
    
	//重写equals方法
    @Override  
    public boolean equals(Object o) {  
        if (this == o)  
            return true;  
        if (o == null || getClass() != o.getClass())  
            return false;  
  
        MyString myString = (MyString) o;  
        return Objects.equals(value, myString.value);  
    }  
    
	//重写hashCode方法
    @Override  
    public int hashCode() {  
        return Objects.hash(value);  
    }  
}


//测试使用
public class Test {  
    public static void main(String[] args) {  
        MyString str1 = new MyString("Hello");  
        MyString str2 = new MyString("Hello");  
  
        // 测试重写的 equals 和 hashCode 方法  
        System.out.println(str1.equals(str2));  // 输出 true  
        
        // 将 MyString 对象放入 HashMap        
        Map<MyString, Integer> map = new HashMap<>();  
        map.put(str1, 1);  
        map.put(str2, 2);           
        // 因为str1和str2的hashcode是同一个，所以认为只有一个键，后一个键覆盖类前一个值  

        System.out.println(map.size());  // 输出 1，说明只有一个键值对被加入 Map 中  
    }  
}

```

^22d0ce

思考：做到一个题目
```
Goods对象
{
  “name”: "红富士"，
  “attrList”: [红色, 纯天然, 很甜],
  "count": 10
}

{
  “name”: "红富士"，
  “attrList”: [很甜, 红色, 纯天然],
  "count": 2
}

{
  “name”: "红富士"，
  “attrList”: [纯天然, 红色],
  "count": 5
}

{
  “name”: "小金苹果"，
  “attrList”: [纯天然, 红色],
  "count": 20
}
只要满足：name相同，attrList中的属性相同，就可以合并到一起。

本质就是需要我们重写Goods对象中的equals方法！改写成name相同 且 attrList相同，这两个对象就判断为相同。
故而，重写equals和hashCode方法
    @Override  
    public String toString() {  
        return "Goods{" +  
                "name='" + name + '\'' +  
                ", attrList=" + attrList +  
                ", count=" + count +  
                '}';  
    }  
  
    @Override  
    public boolean equals(Object o) {  
        Goods otherGoods = (Goods) o;  // 类型强转
        List<String> attrList1 = this.getAttrList();  
        List<String> attrList2 = otherGoods.getAttrList();  
        Collections.sort(attrList1);  
        Collections.sort(attrList2);  
        if(this.getName() == otherGoods.getName() && attrList1.equals(attrList2) ){  
            return true;  
        }else{  
            return false;  
        }  
    }  
  
    @Override  
    public int hashCode() {  
        return Objects.hash(name, attrList, count);  
    }
```


#### hashCode()
返回一个对象的哈希值（基于内存中的地址）
==可以用来去重！==  [[Java_03_高级特性#distinct()]]

==重要==：自定义的类中，equals()和hashcode()必须一起重写，可以利用cmd+n，自动生成重写的equals() 和 hashcode()
![[#^b940bd]]

![[Java_03_高级特性#^d7ce71]]
#### clone( )

#### toString( )
返回一个对象的字符串形式。
println默认调用`toString( )`，可以不用调用
```
textBox.setText("Hello Shen");  
System.out.println(textBox.toString());    //println默认调用toString()
System.out.println(textBox);               //可以不用写.toString
```

#### getClass()
返回该对象所有的fields和methods
#### ~~finalize( )~~
一般Java程序员不会用这个方法，一般给定制JVM的开发人员会用的！
当一个对象**首次**考虑要被回收时，会调用其finalize()方法，让这个对象讲一下遗言！
@亡语，啊哈哈哈哈，真是个人才！
一般用法：1、死之前，把数据持久化；2、死之前，看一下资源是否释放了。

底层原理：[[JVM#强、软、弱、虚引用]]
虚引用（PhantomReference + ReferenceQueue），当发生GC时，加到ReferenceQueue中，让它有时间处理后事！

联想到：[[Spring FrameWork#AOP 面向切面编程]]中的后置通知@After

#### notify()
唤醒wait的线程！
一旦执行此方法，就会唤醒被wait()的线程中优先级最高的一个。被唤醒的线程，**从当初被wait()的位置继续执行！**
线程通信的方法。要求同步监视器都可以调用，所以必须是Object类的方法！

![](https://picgo-rockyshen.oss-cn-shanghai.aliyuncs.com/picgo/202408051442627.png)
#### wait()
让当前程序所在线程，进入等待睡眠状态！
特点是：在哪里睡，就在哪里醒。需要用while循环，而不是if判断。
![[Java_03_高级特性#wait() 与 sleep()对比]]


#### notifyAll()
全部叫醒！

注意点：
1、此三个方法，必须在同步代码块（或同步方法中，也即synchronized），不能在Lock接口中使用（Lock需要配合Condition实现线程通信，详见：JUC）。
2、此三个方法的调用者，必须是同步监视器！否则报错：illegalMonitorStateException异常

[[JDBC#ThreadLocal]]  线程本地变量，同一个线程中共享的区域！

### Class类
继承自Object类
表示类模版，这个对象。

下图示中：（堆）Class对象，就是本Clas类的实例化对象，每一种Class有且仅有一个Class对象。
![[JVM#^147e0c]]
![](https://picgo-rockyshen.oss-cn-shanghai.aliyuncs.com/picgo/202407261453549.JPG)
#### 常用方法  
联想到：[[Java_03_高级特性#反射的应用]]

##### forName(String className)
根据类名返回对应的Class对象
##### getName()
返回类的完全限定名

##### getSuperclass()
返回类的父类的Class对象

##### getInterfaces()
返回当前类所有实现接口的数组

##### isInterface()
判断是否为接口

##### isArray()
判断是否为数组

##### newInstance()
无参构造函数创建类的实例

##### getDeclaredFields()
返回类中声明的==所有Fileds属性的数组==

##### getDeclaredMethods()
返回一个包含类声明==所有方法的数组==

##### getDeclaredConstructors()
返回一个包含类==所有构造函数的数组==。



[[Java_01_基础#包装类]]
就是将基元类型包装成对应的引用数据类型。
![[Java_01_基础#^5aca87]]
### 包装类通用方法

##### equals() -> @Override Object类
各种包装类的equals方法都会做两件事：使用`==`来比较两个对象的内存地址是否相同，相同的话返回true，内存地址不同时，接着再去比较对象的属性值，如果相同，也会返回true！


##### static String valueOf(int i)
将给定的基元类型转化为包装类对象
```
int number = 10;
Interger interger = Interger.valueOf(number);
```

将Long类型的时间戳数据，变成String类型！
```
map.put("timestamp",String.valueOf(System.currentTimeMillis()/1000));  //参数5:
```
##### static int parseInt(String str)
将传递参数的数据类型，解析为XXX
```
String str = “123”；
int int = parseInt(str);   //将传递的String类型，解析为Int类型
```

将String类型的随机数nonce，解析为Long类型，与10000L比较！
```
//校验随机数  
if (Long.parseLong(nonce) > 10000L){       // 正常应该存在redis,然后取出来看一下，这里直接通过  
    return handleNoAuth(response);  
}
```

将String类型的时间戳数据，解析为Long类型，与当前时间戳（Long类型），相减，不能超过5分钟。
```
毫秒，除以1000，最后就是秒，相减300秒，也就是5分钟以内！

Long currentTime = System.currentTimeMillis() / 1000;  
if ((currentTime - Long.parseLong(timestamp)) >= 60 * 5 ) {  
    return handleNoAuth(response);  
}
```
##### xxxValue()
intValue(), doubleValue(), booleanValue()
将包装类转换为相应的基元类型。
```
Interger integer = 10;
int num = integer.intValue();    //将Integer类，转化为int基元类型
```


### String类
#### 基本特点
- 1、final类，不能再被继承了！
- 2、实现Serializable，可以被网络或IO流传输的类
- 3、实现Comparable，可以比较大小 ^26674f
- 4、本质上 :jdk8时存在char型数组中！ jdk9开始存在byte型数组中
```
private final char[] value;    // final，一旦指明，不可变！

private final byte[] value;
```

 String类是不可变的char型数组，见String类的源码，用final修饰
 ```
 public final class String  
    implements java.io.Serializable, Comparable<String>, CharSequence,  
               Constable, ConstantDesc {
    private final byte[] value;    # final修饰
}
```

- 5、字符串常量的存储位置
见下对比，由于字符串在开发中太常用了，所以单独在内存中开辟一个区域存放字符串常量池。
1、字面量方式声明的字符串，直接写入字符串常量池；2、intern()方法调用后，也会写入字符串常量池
```
String s1 = new String("hello");

String s1 = "hello";   
String s2 = "hello";

sout(s1 == s2)
输出：true

s2 += "world";   // 这个不再常量池中发生，直接推进到堆中，作为new的一个对象！

```

- 6、当对现有字符串进行拼接、或replace操作时，可以理解为new一个新对象，需要在堆中开辟空间，不再字符串常量池中了。 String的不可变性！ ^602256
#### 构造方法
##### "test" 字面量
字面量构造的，会存入字符串常量池
```
String s1 = “test”;
```
##### new String(“test”)
不会存入字符串常量池，直接去堆空间中创建对象
```
String()                                    # 空参，char型数组，长度为0
String("orignal")                           # 传递一个字符串进去 
```

##### intern()
如果不存在，就在字符串常量池创建一个；
如果存在，就返回字符串常量池中的引用。

```
String s1 = "abc";  
String s2 = new String("abc").intern();  
  
System.out.println(s1 == s2);    // 不调用intern，返回false;调用intern，返回true
```

这是一个native方法哦！

##### new String(`char[]`)
char型数组，没人会这么创建字符串吧😂
```
String(char[ ] value)           # new String(new char[]{'a', 'b', 'c'})  str.toCharArray()
String(char[ ] value, int offset, int count)
```

##### String与char型数组的转换
str.toCharArray()
将字符串转化为char型数组！常用于算法上
```
char[] chars = str.toCharArray();

String str = new String(chars);
```
##### new String(`byte[]`)
byte型数组，也没有人会这么创建字符串吧
```
String(byte[ ] bytes)                       # 不指明字符集，必须要前后一致；
String(byte[ ] bytes, String chasetName)    # 也可以指明字符集
```

##### String与byte型数组的转换
str.getBytes()
String类型，转化为byte型数组，使用默认字符集（utf-8）
String类型于byte型数组的转换
```
byte[] bytes = str.getBytes();

String str = new String(bytes);
```

指明字符集
```
str.getBytes("gbk")；   // 指明字符集！
```

#### String的拼接/拆分操作
![[#^602256]]

常量 + 常量  ： 结果还是常量，还在字符串常量池中
	常量，可能是字面量，也可能是final修饰的常量。
常量 + 变量，变量 + 变量：都会new出一个新的字符串对象，返回的是堆空间中此对象的地址
调用intern()：返回的是字符串常量池中字面量的地址。（不存在就创建一个）
##### s1 + s2
```
String s1 = "hello";  
String s2 = "world";

String s7 = s1 + s2;   // 常量 + 常量，还是一个常量
```

##### String concat()
拼接，会生成新的对象！
不管是常量调用此方法，还是变量调用此方法。不管参数是常量还是变量。总之，调用完concat方法之后，都返回一个新new的对象！
```
String s1 = "hello";
String s2 = "world";

String s3 = s1.concat(s2);
```

##### `String[]` split()
指定的分隔符对字符串进行拆分，返回一个字符串数组。
```
String str = "apple,banana,orange";

String[] arr = str.split(",");
 
System.out.println(Arrays.toString(arr)); // 输出 [apple, banana, orange]
```

##### static String join()
String类的静态方法，将一个String类下的数组合并为一个字符串，用符号连接
```
String[] arr = {"apple", "banana", "orange"};

String result = String.join(",", arr);

System.out.println(result); // 输出 apple,banana,orange
```

#### 常用方法
##### equals() -> @Override Object类
String类中，重写了equals方法，判断字符串的内容是否相同！区分大小写的！

需要注意：空指针异常 
![[Java_01_基础#^3ee420]]
```
对象.equals("userName")    // 如果对象为空，容易出现空指针异常


"userName".equals(对象)   // 这种写法可以避免空指针异常
```

##### boolean equalsIgnoreCase()
比较字符串是否相等，忽略大小写
##### boolean isEmpty()
判断当前字符串是否为空
```
String str = null;  
System.out.println(str.isEmpty());

# 空指针异常：java.lang.NullPointerException
```

![[#^028e43]]

注意：Apache common lang的isEmpty可以处理null的空指针异常，但是Object类的通用方法isEmpty无法处理null的空指针异常！ ^21ee45

##### int length()
返回字符串的长度

##### int compareTo(String other)   --实现-->  Comparablable接口
![[#^26674f]]
对[[#Comparable接口]]中约定的[[#compareTo(T o)]]]接口方法在的实现！

比较字符串大小，区别大小写，按照Unicode编码值比较大小

##### int compareToIgnoreCase(String other)
忽略大小写的情况下，比较大小写

##### toUpperCase()
toLowerCase()
将字符串转换为：大写、小写。

中文转换成大小写，没有任何变化！
##### toLowerCase()
toLowerCase()
将字符串转换为：大写、小写。

##### trim()
只会去除字符串前后两头的空格，中间的空格不会去除！

*********
==**查找相关**==
##### boolean contains(“test”)
当前字符串是否包含xxx

##### int indexOf("test")
从前往后查找xx第一次出现的索引位置
注意：参数必须完全匹配，才会返回第一个索引位置，如果不一样，就会返回-1
```
String s3 = "尚硅谷教育";
int i = s3.indexOf("硅谷");  
System.out.println(i);

输出：1

char型数组
[尚 硅 谷 教 育]
 0  1  2  3  4 
    ^

String s3 = "尚硅谷教育";
int i = s3.indexOf("硅谷a");  
System.out.println(i);

不完全匹配，就认定为没找到，返回-1
```

##### 【重载】int indexOf("test", int fromIndex)
从指定的索引位置开始，往后找，跳过一部分

##### int lastIndexOf("text")
从后往前找，返回后面开始，找到的第一个索引。

##### 【重载】int lastIndex("text", int fromIndex)
从后面开始，跳过一部分，开始找

##### String substring(int beginIndex)
截取字符串中一部分
```
"hamburger".substring(4, 8) 

returns "urge"
```

底层就是new String(value, beginIndex, subLen)
##### 【重载】String substring(int beginIndex, int endIndex)
指定开始、和结束的位置   左闭右开区间！

==在Java中，begin和end，默认都是左闭右开区间！==


##### format()
进行字符串格式化，其中 `%s` 是占位符，用于插入变量的值

在 Java 中
• %s 代表字符串格式化占位符，用于插入字符串变量。
• %d 代表整数格式化占位符，用于插入整数变量。

```
String.format("prize_coupon_"+"%s", prizeId)   # 相当于把prizeId拼接在后面
```




***************
==**char数组相关**==
##### char charAt(index)
返回索引处的单个字符，数据类型就是：char，单个字符
```
        String s3 = "hello";  
        char c = s3.charAt(2);
```

##### static String valueOf(`char[]` data)
静态方法，将char型数组转换为字符串
```
char[] arr = new char[]{'a','b','s'};  
String s = String.valueOf(arr);  

System.out.println(s);
```

##### static String copyValueOf(`char[]` data)
新new一个对象，一份拷贝！

********
==**开头结尾相关**==
##### boolean startWith("test")
是否以指定位置开始

##### 【重载】boolean startWith("test", int toOffser)
从指定索引处开始查询匹配！

##### boolean endWith("test") 
返回布尔值，是否以指定后缀结尾

*******
==**替换相关**==
##### String replace(char oldChar,  char newChar) 
用oldChar 替换成 newChar，然后返回一个字符串

注意：这个replace方法不会改变原来message的值，而是创建一个新的！

关于Parameter 和 Argument的理解： ^cae751
Parameters是形参，是：target和replacement
Arguments是实参， 是 ：“!” 和 “~”   ^3f6a72
```
replace(target:"~", replacement:"~")
```

转义符
Windows路径的转义  `"C:\\Users\\61750"`  两个`\`，其中一个是转义符
`\n`   表示换行符
`\t`    表示tab制表符

##### 【重载】String replace(CharSequence target, CharSequence replacement)
除了上面的单个char，也可以是字符串（charsequence 字符串序列）

```
String s2 = s1.replace("ll", "www");
```

##### replaceAll(String regex, String replacement)
使用给定的replacement替换此字符串中匹配正则的子字符串
[[re.正则表达式]]

##### replaceFirst(String regex, String replacement)
使用给定的replacement替换此字符串中匹配正则的第一个子字符串

| XX             | XX                                                               |
| -------------- | ---------------------------------------------------------------- |
| String类        | 不可变的字符序列；<br>                                                    |
| StringBuffer类  | 可变的字符序列；<br>JDK 1.0引入，线程安全的（方法都加了synchronized）；效率低一些（都比String高效） |
| StringBuilder类 | 可变的字符序列；<br>JDK 5.0引入，线程不安全；效率高一些（都比String高效）                    |
不可变：是指“hello”这个字符串的结构，是不可变的。三个对象引用字符串常量池的同一个字符串，任何人想改，都必须去新new一个对象！
可变：是指“hello”这个字符串的结构，是可变的。可以在原来的字符串后面直接拼接！“helloworld”

### StringBuilder类
可变的字符序列；线程不安全；性能最好！

![[#^8d848b]]

#### 常用方法
##### StringBuffer append("text")
在现有的char型数组中，往后添加
可以链式调用
```
StringBuilder sBuilder = new StringBuilder();
sBuilder.append("abc").append("efg");
```
##### StringBuffer delete(int start, int end)
删除指定范围内的字符
##### StringBuffer deleteCharAt(int index)
删除指定索引位置的单个char
##### replace(int start, int end, String str)
从start到end，改为str
超过，或不足都没关系的！
##### setCharAt(int index, char c)
将指定索引位置的char单个字符，改为c
##### charAt(int index)
查看指定位置的单个字符
##### StringBuffer insert(int index, xx)
在index索引处，插入一个新的xxx
##### int length()
返回StringBuilder的长度，返回的是实际存储的字符的个数
##### int setLength(int newLength)
截取一段，count设置为指定的数。后面多余的字符会无视！
如果set一个大的数值，拿“`0`”去填充！
##### reverse()
反转，String里没有这个反转

### StringBuffer类
可变的字符序列，线程安全的！
StringBuffer所有方法，都加了synchronized，线程安全！

StringBuffer和StringBuilder这哥两，都会继承自：AbstractStringBuilder类 ^8d848b

唯一的区别，就是一个线程安全、一个线程不安全
#### 可变性分析
见源码：
```
abstract class AbstractStringBuilder implements Appendable, CharSequence {     
    byte[] value;    # 没有用final修饰，可变长度！引用可以换来换去
	byte coder;  
	int count;       # 实际存储的字符个数！
```

思考：用final和没有用final修饰的数组，有什么不同特点？
1、数组的引用不可变，你不能再让这个数组引用指向其他数组；
2、数组中的元素是可变的，但是内存空间是固定的，个数也就是固定的。

空出来的16个位置干什么用呢？方便后面可以添加元素，预留的！
```
StringBuilder sBuilder = new StringBuilder();
// 底层其实new了一个char[16]，默认是16个容量，这16个桶里一个元素也没放；

StringBuilder sBuilder = new StringBuilder(“abc”);
// 前面16个位置始终空着，新创建的都往后接。
```

不断添加，超过16个空位置的时候，就更新一个引用。

见源代码中
ensureCapacityInternal(minimunCapacity) -> newCapacity(minimunCapacity)
	方法内部，利用位运算符进行扩容 value.lenght << 1 + 2 (等价于value.length * 2 + 2）
	
扩容：原容量2倍+2！并将原有value的`char[]`复制到新位置上！

#### 三个类的选择
1、如果开发中，需要频繁针对字符串进行CRUD操作，建议使用StringBuffer和StringBuilder替换String。因为String效率低；
2、如果开发中，不涉及线程安全问题，建议使用StringBuilder，不用每次去握锁synchronized。
3、如果开发中，基本确定字符个数大于16个时，可以使用new StringBuilder(int capacity)，避免底层频繁扩容。
```
StringBuilder sBuilder = new StringBuilder(50);     

// 提前创建一个50个位置的char[]数组，避免一上来就频繁扩容
```

#### 常用方法
同StringBuilder，只是多了synchronized同步关键字！

- append(String str)    在字符串末尾追加一个字符串
- insert(int offset, String str)   在指定位置插入一个字符串     offset  偏移量
- delete(int start, int end)       删除指定范围内的字符
- deleteCharAt(int index)       删除指定位置上的字符
- replace(int start, int end, String str)    用新字符串替换指定范围内的字符
- reverse()         将字符串进行反转
- toString()        将StringBuilder对象转为String对象


### Integer类
#### Integer.parseInt(String str)
静态方法，将字符串转换为整数值
#### intValue()
longValue() floatValue() doubleValue()  将Integer类的实例对象转为对应基元类型
#### toString()
将整数转为字符串类型String类
#### compareTo(Integer, AnotherInteger)
对[[#Comparable接口]]中约定的[[#compareTo(T o)]]]抽象方法在Integer类的实现！
两个Integer类的实例比较大小
	- 返回值大于0，表示当前对象大于AnotherInteger
	- 返回值小于0，表示当前对象小于AnotherInteger
	- 返回值等于0，表示两个对象相等

#### o1.equals(Object obj2)

判断obj1与obj2是否相等
#### valueOf(int i)
@override 包装类中的方法
返回指定整数值i的Integer对象
#### reverse(int i)
反转整数位数，例如12345，返回54321

***************************
## Iterable接口
Iterable接口下只定义了一个迭代器iterator()，具备循环遍历功能。
![](https://raw.githubusercontent.com/rockyshen/blog-img/master/%E6%88%AA%E5%B1%8F2024-02-01%2022.06.27.png)

```
//迭代器的遍历结构

Set keySet = map.keySet();
Iterator iterrator = keySet.iterator();
while (iterator.hasNext()) {
	System.out.println(iterator.next());
}
```

^5ce23f

### 接口规约方法 -> iterator()
通过观察iterator迭代器的底层实现，其实使用的是链表和指针！

可以简化为for each 
```
var list = new GenericList<String>;    // GenericList实现了Iterable接口
for (var item : list) {
	System.out.println(item);
}

```

实现Iterator接口，要重写： hasNext()  next()这三个方法！

返回一个迭代器如何使用？


## Comparable`<T>`接口
自然排序，比较器
基本数据类型，直接用[[Java_01_基础#比较运算符]]即可！但是，你考虑过引用数据类型的感受吗？它们也想要互相比较，不能用比较运算符，需要自定义比较规则，就需要在此接口中实现自定义逻辑。

联想到：[[#Comparator`<T>`接口]] 可以看作：定制排序，独立比较器
泛型类，一般都要实现对比的逻辑！

| User implements Comparable`<User>` | XxxComparator implements Comparator`<Customer>` |
| ---------------------------------- | ----------------------------------------------- |
| 自然排序                               | 定制排序                                            |
| 单一的，唯一的                            | 灵活的、多样的                                         |
| 一劳永逸                               | 临时的                                             |
| 抽象方法[[#接口规约方法 -> compareTo(T o)]]  | 抽象方法[[#compare(T o1, T o2)]]                    |
| 基于实体类去实现接口                         | 基于比较器类去实现接口                                     |
| 写在实体类内部@override                   | 单独写一个比较器类，<br>然后把两个对象传到比较器实例中                   |
|                                    | 可以把比较器对象作为参数，传递个sort(比较器)                       |

规则：
- 如果返回值是正数，当前对象大
- 如果返回值是负数，当前对象小
- 如果返回0，一样大；

示例代码，基于User类implements Comparable接口。
可以实现为比较他们的名字是否相等，或者生日是否相等，完全取决于你的逻辑。
```
手写User类的比较逻辑，基于User的Field:points来比较

public class User implements Comparable<User> {  
    // Field
    private int points;  
	// 全参构造器
    public User(int points) {  
        this.points = points;  
    }  
  
    @Override  
    public int compareTo(User o) {  
		if (this.points == o.points){     // 一样大
            return 0;  		
		}
        elif (this.points < o.points){    // 本类的当前实例小
            return -1;
        }  
        return 1;                        // 本类的当前实例大
    }  
}
```

### 接口规约方法 -> compareTo(T o)
Comparable接口的抽象方法，定义同一个类之间不同实例的比较逻辑。
实现在类的内部，使得类具备可比较性！

**返回值：Integer类型的：0、1、-1**

x.compareTo (y )
	x小于y，返回-1
	x等于y，返回0
	x大于y，返回1 ^181b03
```
public class Student implements Comparable<Student> {
	//Field
	private String name;
	private int age;

	@override
	public int compareTo(Student other) {
		return this.age - other.age;
	}
}
```

**Q：Comparable接口 和 Comparator接口有什么区别？**
-  Comparable接口，更通用，在类内部定义了对象自身的比较规则（在类内部通过@override重写compareTo实现）。一个类实现Comparable接口，必须要@override重写compareTo方法。
- Comparator接口，是一个外部比较器接口，可以比较不同对象之间的顺序。定制比较逻辑，自定义功能更强！但是需要一个独立的比较器类来实现（外部比较器）。可以传入两个不同类的对象，@override重写compare方法来定制规则
- 通常情况下，我们统一通过实现Comparator接口来创建一个比较器类，实例化的对象可以作为参数传递给一些排序方法：如[[#Arrays.sort()]]或[[#Collections.sort()]]，覆盖默认的排序规则，提供自定义排序规则，看例子： ^f9a46e


## Thread类
通过继承Thread类的方式，创建线程：![[Java_03_高级特性#^874c89]]![[Java_03_高级特性#^b08324]]![[Java_03_高级特性#^ef90e2]]
### 常用方法
[[Java_03_高级特性#Thread类的常用方法]]
#### start()
启动线程，并执行线程的run()方法
#### run()
线程的执行体，通过实现Runnable接口，重写的run()方法
#### sleep(long millis)
让当前线程休眠指定毫秒数
#### void interrupt()
处于正常状态的线程，将中断状态标识位设置为true；后续需要程序员手动处理！
	1、只是将中断状态设置为true，==不会终止线程==（线程的命运应该掌握在自己手中，不应该被别的线程停止掉）。
	2、响应中断：线程内部收到外部设置的这个中断状态后，需要自己处理中断逻辑！

~~stop()终止线程，太过于暴力！已被废弃~~
interupted()中断线程，更加柔和，运行JVM执行GC等！

那如何中断呢？配合isInterrupted()方法，中断协商机制的示例代码
```
/**  
 * V3 : 通过interruptAPI，实现线程中断  
 */  
public static void m3_InterruptAPI(){  
    Thread t1 = new Thread(() -> {  
        //线程需要执行的逻辑  
        while (true) {  
            if (Thread.currentThread().isInterrupted()) {  
                System.out.println(Thread.currentThread().getName() + "\t isInterrupted的值被修改为true，程序停止");  
                break;  
            }  
            System.out.println("---hello interruptAPI");  
        }  
    }, "t1");  
    t1.start();  
  
    try {TimeUnit.MILLISECONDS.sleep(50);} catch (InterruptedException e) {throw new RuntimeException(e);}  
  
    new Thread(()->{  
        //线程需要执行的逻辑  
        // 发起协商，要求t1中断的协商  
        t1.interrupt();  
    },"t2").start();  
}
```
#### boolean isInterrupted()
判断当前线程是否被终端，返回true or false

Q：interrupt() 和 interrupted() 有什么区别？ #Java八股/JUC 
A：interrupt()是将中断状态设为true；interruptted()是检查是否中断状态，并清除掉中断状态！
#### static boolean interrupted()
==**静态方法**==，做了两件事：1、返回当前中断标识位的值true or false ，2、如果是true，==并清除中断状态==

#### 线程中断机制
1、一个线程不应该由其他线程中断或停止，应该由自己自行停止（命运掌握在自己手上）
2、在Java中没有办法立即停止一条线程，有时候一个耗时操作必须要停掉，Java提出了一种中断标识协商机制！

中断只是一种协商机制。若要中断一个线程，需要手动调用线程的interrupt()方法，该方法也只是将线程对象的中断标识设置为true！接下来你需要自己在线程的代码中检测并判断中断标识位，如果为true，表示别的线程请求你这个线程中断。此时究竟怎么做，需要程序员自己写代码实现！

具体实现停止中断运行中的线程：详见juc-part/interrupt/InterruptDemo中有示例！
1、通过[[Java_03_高级特性#volatile关键字]]变量
2、通过AtomicBoolean
3、通过Thread类自带的中断API实例方法 ^eccb16

如果t1线程处于阻塞状态（例如sleep、wait、join等状态），在t2线程中调用t1.interrupt()尝试给一个被阻塞的线程设置中断，那么这个阻塞的线程会立刻退出阻塞状态，并抛出InterruptException异常！ ^619a87

#### join()
等待线程终止

#### notify() -> @Override Object类
唤醒被阻塞的（例如执行了wait()方法的线程）线程

1、使用wait()和notify()必须包在锁块之间，否则报错 ！
2、wait()必须前，notify()必须在后，否则wait持续在那边，卡住！ ^06143b
#### wait() -> @Overried Object类
使当前线程阻塞（并且释放锁），sleep是抱着锁睡觉（不会释放锁）

#### 线程等待唤醒机制
有3种让线程等待和唤醒的方法
1、使用Object类种的方法[[#wait() -> @Overried Object类]]让线程等待，使用[[#notify() -> @Override Object类]]唤醒线程
2、使用[[JUC#Condition接口]]种的[[JUC#await()]]让线程等待，使用[[JUC#signal()]]让线程唤醒
3、使用[[JUC#LockSupport类]]可以阻塞当前线程、唤醒指定被阻塞的线程。
#### getName()
获取线程名字
#### getId()
获取线程id
#### setName(String name)
设置线程名称
#### getPriority()
获取线程优先级
#### setPriority(int number)
设置线程优先级
![[Java_03_高级特性#^a7bcad]]
#### isAlive()
检查线程是否存活

#### Thread.currentThread()
获取当前正在执行的线程，这个对象实例
```
Thread.currentThread.getName();
```

## ThreadLocal类
[[JUC#`ThreadLocal<T>`类]]

## System类
访问系统资源，与系统进行交互的API入口

### static Field
只属于类的属性，静态属性！
#### 静态属性 in
InputStream类型的对象
用于从控制台接收用户输入的数据。
通常，使用 System.in 结合 Scanner 类来读取控制台输入的数据。
##### new Scanner(System.in)
```
import java.util.Scanner;

public class InputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("请输入一个整数：");
        int num = scanner.nextInt();  // 从控制台读取一个整数
        System.out.println("您输入的整数是：" + num);
        scanner.close();
    }
}
```

#### 静态属性 out
PrintStream类型的对象；![[Java_03_高级特性#^cb4566]]
#####  System.out.println()
标准输出流，😄，接触Java的第一行代码！
```
System.out.println(data)
```

### 常用方法
#### System.getenv(String name)
获取指定名称的环境变量值。

#### currentTimeMillis()
当前时间的时间戳，==Long类型==，毫秒级

应用场景：
1、一般用于计算时间差！
2、订单号，全球唯一！

时间戳：表示了自格林威治标准时间 1970 年 1 月 1 日 00:00:00 GMT（或称为 UNIX 时间戳）以来的毫秒数。该时间戳不包含与日期和时区相关的信息，只表示时间经过的毫秒数。 ^49ad31
```
@Test  
public void testTime(){  
    long timestamp = System.currentTimeMillis();  
    System.out.println(timestamp);  
}

>> 1720751041974   这是从1970年1月1日，到今天2024年7月12日，过去的描述
```

^cb08df

将Long类型的时间戳，转为字符串类型
```
String.valueOf(Long timestamp)；
```

结合[[#valueOf()]]将时间戳变成String
```
map.put("timestamp",String.valueOf(System.currentTimeMillis()/1000));  //参数5:
```

System.currentTimeMillis()   返回的是时间戳，是一个Long类型的数字
java.time包中的[[#LocalDateTime.now()]]，返回的是：2024-07-12T10:49:43.456244

补，总结所有时间相关的类！表格

## Exceptions类
包含编译时的错误信息，每个被抛出的异常，都是一个实例化对象。


## Math类
提供一系列数学运算方法和常量

静态方法，直接基于类来调用：
Math.round(1.1F)        四舍五入
Math.ceil(1.1F)            向上取整
Math.floor(1.1F)          向下取整
Math.max(1, 2)            返回最大值
Math.min(1, 2)             返回最小值
Math.random()            返回0-1之间随机数
```
int result = (int) (Math.random() * 100)   //生成0-100随机整数
             Math.random生成的是long类型，无法隐式转换成int,需要手动转
```
### 常量
Math.PI       圆周率pi的近似值
Math.E        自然对数e的底数的近似值
### 常用方法
- abs()
- sqrt()
- pow(底数，指数)
	- 指数幂，返回double类型的结果。
		注意：Math.pow()方法的返回值为double类型，即使指数是整数，结果也将是一个浮点数。如果需要得到整数结果，可以进行类型转换。
- max()  min()
- random()
- round()
- ceil()
- floor()

## Number类
### Striped64类
LongAdder性能明显优于AtomicLong，就是因为Striped64类在底层起到作用！

静态内部类 Cell类
![[Java_02_面向对象#^876f5b]]

NCPU：本机CPU 
cells：Cell类型的数组 `Cell[]`
base：更新值
cellsBusy：某个cell格子是否忙碌

[[JUC#【实现类】LongAdder]]
![](https://picgo-rockyshen.oss-cn-shanghai.aliyuncs.com/picgo/202408021055232.png)

## #.reflect包
反射
### Proxy类
JDK动态代理类




# java.util包
工具库
![[#^887a3e]]

## Collection接口
Collection接口跨包继承了lang包下的[[#Iterable接口]]，使其具备迭代功能。在此基础上拓展了添加、移除、查询元素等。 ^ac7f96

![](https://raw.githubusercontent.com/rockyshen/blog-img/master/Scannable%E6%96%87%E6%A1%A3%E5%88%9B%E5%BB%BA%E4%BA%8E2024%E5%B9%B44%E6%9C%885%E6%97%A5%2022_26_51.jpg)

有个误区，python中的List其实等于Java中的ArrayList实现类。在Java中List是一个接口，不能直接使用的。要用的都是ArrayList以及Arrays类提供的各种方法！

### [[Java_03_高级特性#List接口]]
约定：有序的集合、允许重复元素、可以根据索引访问元素

#### [[Java_03_高级特性#【实现类】ArrayList类]]
[[数据结构-数组]]

[[#Arrays类]]
![[Java_01_基础#^74d716]]

#### [[Java_03_高级特性#【实现类】LinkedList类]]
[[数据结构-链表]]

### [[Java_03_高级特性#Set接口]]

#### [[Java_03_高级特性#【实现类】HashSet类]]

### [[Java_03_高级特性#Map接口]]

#### [[Java_03_高级特性#【实现类】HashMap类]]
[[数据结构-哈希表]]

### [[Java_03_高级特性#Queue接口]]

#### [[Java_03_高级特性#【实现类】ArrayDeque类]]
[[数据结构_队列]]

#### [[Java_03_高级特性#【实现类】PriorityQueue类]]


## Iterator接口
对collection进行迭代的迭代器，取代了之前的Enumeration

Q：什么是fail-fast和fail-safe
A：是多线程并发操作中集合处理失败的机制。
fail-fast，在集合遍历过程中，一旦返现集合中数据被修改，立刻抛出ConcurrentModificationException，导致遍历失败
fail-safe，在集合遍历过程中，如果发现集合中数据被修改，不抛出异常！（采用副本方式）

### 接口规约方法
#### hasNext()
如果后面仍然有元素，返回true

#### next()
返回迭代的下一个元素

#### remove()
从迭代器指向的collection中移除最后一个返回的元素。

Iterator使用的示例代码
```
List<String> list = new ArrayList<>();
Iterator<String> iterator = list.iterator();

while(iterator.hasNext()) {
	String obj = iterator.next();
	sout(obj);
}
```

## Lock接口

## Callable接口
创建线程的方式之一，实现call()方法

## Executor接口
此接口对象能执行我们的线程任务。

## Executors类


## Comparator`<T>`接口
定制排序，外部比较器的接口。
注意：![[Java_03_高级特性#^e963da]]
[[#Comparable`<T>`接口]]可以看作是：自然排序！比较两个对象的大小。
与[[#Comparable`<T>`接口]]不同的是，定制排序，可以独立于被比较对象进行比较。

![](https://picgo-rockyshen.oss-cn-shanghai.aliyuncs.com/picgo/202409151329691.png)

| User implements Comparable`<User>` | XxxComparator implements Comparator`<Customer>` |
| ---------------------------------- | ----------------------------------------------- |
| 自然排序                               | 定制排序                                            |
| 单一的，唯一的                            | 灵活的、多样的                                         |
| 一劳永逸                               | 临时的                                             |
| 抽象方法[[#接口规约方法 -> compareTo(T o)]]  | 抽象方法[[#compare(T o1, T o2)]]                    |
| 基于实体类去实现接口                         | 基于比较器类去实现接口                                     |
| 写在实体类内部@override                   | 单独写一个比较器类，<br>然后把两个对象传到比较器实例中                   |

适用场景：当我们使用的是一些原生的类（或者框架内置的类），我也想让这个类具有比较的特性，不可能去到类文件中，给它加上`implement Comparable`，我不可能去修改它的源代码。此时就可以写一个独立的`XxxComparator implement Comparator`，定制排序规则。

例如，我想实现一个比较逻辑，基于数组，哪个数组的元素多，就表示哪个数组大，这个时候我们不可能去数组的源代码中去改，就可以自定义一个数组比较器，见下示例：
```
public class ArrayCompartor implements Comparator<int[]> {  
    /**  
     * 在本自定义比较器中：  
     * 如果o1的长度大，那么就o1大；如果o2的长度大，那么就o2大！  
     * @param o1 the first object to be compared.  
     * @param o2 the second object to be compared.  
     * @return 1：o1大于o2  0：o1等于o2  -1:o1小于o2  
     */    @Override  
    public int compare(int[] o1, int[] o2) {  
        return o1.length - o2.length;  
    }  
}
```

有了这个比较器，我们就能对包含数组的数组进行整体排序。
```
[[1,2,3], [1,2], [1,2,3,4,5]]

// new出来的自定义比较器，是按照数组的元素多少来比较大小的。  
ArrayCompartor arrayCompartor = new ArrayCompartor();  

// new一个二维数组，用于测试排序  
int[][] arrInt4 = new int[][]{{1,2,3},{1,2},{1,2,3,4,5}};  

Arrays.sort(arrInt4,arrayCompartor);  
// 打印看一下是否按自定义比较器进行了排序  

for (int[] arr : arrInt4) {  
    System.out.println(Arrays.toString(arr));  
}

输出结果：已经是排好序的！
[1, 2]
[1, 2, 3]
[1, 2, 3, 4, 5]

```

### 接口规约方法
#### compare(T o1, T o2)
在外部比较器Comparator接口中，定义约定了抽象方法compare()方法
`compare(x, y)` 
x小于y，返回-1
x等于y，返回0
x大于y，返回1

```
public static Comparator<Student> NameComparator = new Comparator<>() {
	@override
	public int compare(Student s1, Student s2)
		return s1.name.compareTo(s1.name);
}
```

 
`comparing(Function<T>keyExtractor)`
静态方法，基于类调用：Comparator.comparing()
创建一个比较器，接收一个Function类型 函数式接口 的参数keyExtractor，用来提取对象的某个关键属性值。比较器会根据提取到的值进行比较。返回一个Comparator类的对象实例。


## Arrays类
一个包装类，包含很多静态方法，不能被实例化！
操作：常规数组`[]`和 动态数组ArrayList的方法集合！
#### toString()
将数组转换为字符串并返回。
```
String arrString = Arrays.toString(arr)
```
#### equals()
比较两个数组是否相等
```
boolean isEqual = Arrays.equals(arr1, arr2);
```
#### Arrays.sort()
对数组的元素进行排序

联动[[#Comparator`<T>`接口]]提供的自定义比较器，实现自定义排序
![[#^f9a46e]]

#### binarySearch()
对已经排序的数组进行二分查找

Parameters:
`a` - the array to be searched，需要被搜索的数组
`key` - the value to be searched for，被搜索的值

Returns:
index of the search key，返回index索引位置。

#### `fill(int[] a, int fromIndex, int toIndex, int val)`
数组的填充，从fromINDEX 到 toIndex

fill(T`[]` a, T val)   将val值填满a数组

#### copyOf(T`[]` original, int newLength)
复制指定长度的数组
#### Arrays.asList()
1、将`基本数组[]`转换为List
2、【最方便】假如你知道要往列表中放什么元素，可以用Arrays.asList()直接放，但是不可变的固定大小List！

注意：数组(Array) 转 列表(ArrayList)：使用Arrays.asList(array)进行转换。但是不推荐哦！因为Arrays.asList 方法创建的 List 是一个==不可变的固定大小==的 List，不支持后续的添加、删除或修改操作。任何尝试修改这个 List 的操作都会导致 UnsupportedOperationException 异常。无法使用add、remove方法 ^c3031a

```
// array to list
String[] array = new String[] {
	"王磊","的诗情画意"
};
Arrays.asList(array)
```

asList(e1, e2,…)
将传递的多个参数合并成一个ArrayList

#### stream()
将一个[]数组，先转成Array类，然后调用stream  [[Java_03_高级特性#创建Stream]]

## Collections类
一个包装类，包含很多静态方法，不能被实例化！
操作Collection的方法集合
### 常用方法
#### Collections.sort()
对集合进行排序

需求：两个list，里面的字符串相同就算相同，不关心顺序，应该怎么写？
思路：利用Collections.sort(list)，进行一下排序，两个列表都排一下序，最后就是一样的顺序了，就能用equals来判断了！
```
List<String> attrList1 = this.getAttrList();  
List<String> attrList2 = otherGoods.getAttrList();  

Collections.sort(attrList1);  
Collections.sort(attrList2);

attrList1.equals(attrList2)
```

联动[[#Comparator`<T>`接口]]提供的自定义比较器，实现自定义排序
![[#^f9a46e]]

#### binarySearch()
对已排好序的集合进行二分查找

#### `synchronizedList(List<T> list)`
利用Collections类提供的，线程安全方法！
```
List<String> list = Collections.synchronizedList(new ArrayList<>());
```

## Scanner类
从用户的输入中获取数据
[[Java_03_高级特性#标准输入输出流]]
### 常用方法
- next( )
从输入中读取一个字符串，并将其返回。遇到空白字符就结束。

- nextInt()
从输入中读取一个整数，并将其返回。
注意，只会读一个整数，需要读多个整数，需要使用循环来重复调用此方法！

- nextLine()
从输入中读取一行字符串，并将其返回，遇到空白符不会结束

补充Collection接口及实现的图：

## Ramdon类
生成随机数的工具类

### 常用方法
#### setSeed()
给随机数生成器，加入一点随机性因子，一颗种子（可选）

#### nextInt(int bound)
返回0-bound边界的一个随机数，包含0，但不包含边界


生成一定范围随机数的好例子：
```
/**  
 * 利用当前系统时间的时间戳作为随机数种子，这样保证随机下  
 * 最后生成一个0-10000之间随机数  
 */  
public class UtilTools {  
    public static int getRandom(int maxValue) {  
        Random random = new Random();  
        //设置随机数种子  
        random.setSeed(System.currentTimeMillis());  
        return random.nextInt(maxValue);  
    }
```

## 【弃用】~~Date类~~
最基本的日期和时间类，已经过时，推荐使用[[#java.time包]]

java.util.Date类
java.sq.Date类，两个注意区分，sql包下的Data类是util包下Date类的子类。

### 两个构造器

#### new Date()
空参构造方法，返回当前时间
#### new Date(long timeMillis)
基于指定时间戳的Date实例

### 两个常用方法
#### toString()
将当前系统时间，用便于人类阅读的方式打印出来
```
Date date1 = new Date();

sout(date1.toString());

输出：Mon Dec 05 11:56:26 CST 2022
```
注意java.sql.Date类的toString，打印出来的是：2022-12-05。是不同的

#### getTime()
返回毫秒数
```
long milliTimes = date1.getTime();

>> 1670212256045
```
联想到：System类下的：[[#currentTimeMillis()]]方法

## 【弃用】~~Calendar类~~
注意：Calendar类是抽象类，java.util.Date类中大部分被弃用，替换为Calendar类。
实际操作的是：GregorianCalendar类

获取Calendar实例的方法  [[设计模式#Singleton 单例模式]]
### 实例化
单例模式下，利用静态方法getInstance()获取实例，常规构造方法被设置为private  [[设计模式#饿汉式步骤]]
复习一下饿汉式的代码
```
class MySingleton {
	// 私有化构造器
	private MySingleton(){};

	// 私有化Field，在上面初始化
	private static MySingleton instance = new MySingleton();

	// 公开获取实例的方法
	public static getInstance(){
		return instance;
	}
}
```

在电脑系统中，只需要一份Calendar实例就行了，没必要new多份！单例模式是适合的！
实例化，实例代码 ^03706e
```
Calendar calendar = Calendar.getInstance();

// 由于Calendar类是抽象类，所以实质上这个类是GregorianCalendar类；
```
### 常用方法
#### static getInstance()

#### get(int field)
Calendar.DAY_OF_MONTH   这个月的第几天
#### set(int field, int value)

#### add(int field, xx)
在现有的天的基础上，累加！


## java.util.logging包
基于 [[#【日志门面】commons.logging包]]的实现！

Java原生的日志记录实现类，日志是为了替代[[#System.out.println()]]，可以定义格式，重定向到文件。

示例
```
import java.util.logging.Level;
import java.util.logging.Logger;

public class Hello {
    public static void main(String[] args) {
        Logger logger = Logger.getGlobal();
        logger.info("start process...");
        logger.warning("memory is running out...");
        logger.fine("ignored.");
        logger.severe("process will be terminated...");
    }
}

输出
# 可以看出：它自动打印了时间、调用类、调用方法等很多有用的信息
Mar 02, 2019 6:32:13 PM Hello main
INFO: start process...

Mar 02, 2019 6:32:13 PM Hello main
WARNING: memory is running out...

Mar 02, 2019 6:32:13 PM Hello main
SEVERE: process will be terminated...

```

JDK的Logging定义了7个日志级别，从严重到普通：
- SEVERE
- WARNING
- INFO  （默认INFO，INFO级别以下的日志，不会被打印出来）
- CONFIG
- FINE
- FINER
- FINEST

Logging日志，存在诸多缺陷：
1、在JVM启动时读取配置文件并完成初始化，一旦开始运行`main()`方法，就无法修改配置；
2、配置不太方便，需要在JVM启动时传递参数`-Djava.util.logging.config.file=<config-file-name>`。
故而，这个类基本不会用的！

# java.net包
## http包
### HttpClient类
java.net.http.HttpClient
Java 11引入的新的标准HTTP客户端库，提供了更现代化的方式来处理HTTP请求。HttpClient支持异步请求、流式API、WebSocket等特性，性能更好且更易于使用。

梳理截止目前，Java中有哪些可以发起Http请求的方式？
1、原生的：java.net下的HttpClient
2、Apache提供的：org.apache.http.client.HttpClient
3、Spring框架提供的：[[Spring FrameWork#~~RestTemplate~~]]、OpenFeign

## [[Java_网络编程#InetAddress类]]
# java.text包

## NumberFormat类
将输入的数据格式化为制定的显示格式！

格式化数字，`java.text.NumberFormat抽象类`

抽象类，不是通过new来创建类的实例化对象；而是通过Factory Method来生产一个实例化对象。

1、货币格式化
```
public class Main {  
    public static void main(String[] args) {  
        NumberFormat currency = NumberFormat.getCurrencyInstance(); // 不同于new实例化
        String result = currency.format(1234567.891);  
        System.out.println(result);  
    }  
}
```

2、百分比格式化
链式调用
```
public class Main {  
    public static void main(String[] args) {  
        // 链式调用方法       方法1：Factory method实例化抽象类   方法2：格式化数字  
        String result = NumberFormat.getPercentInstance().format(0.25);  
        System.out.println(result);  
    }  
}
```
### 常用方法
-  getInstance()
获取默认数字格式化对象
- getCurrencyInstance()
货币格式化对象
-  getPercentInstance()
百分比格式化对象


## SimpleDateFormat类
格式化和解析日期的具体类！
格式化：日期对象  ->  文本
解析：    文本  ->  日期对象

```
// 格式化日期
SimpleDateFormat sdf = new SimpleDateFormat();
Date date = new Date();   // java.util.Date
String strDate = sdf.format(date);

>> 22-12-5 下午2:21   # 按默认format格式输出的样式

// 解析为日期对象
Date date2 = sdf.parse("22-12-5 下午2:21");

>> 输出Date实例对象
```

自定义格式
[官方API参考：Format格式参考](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/SimpleDateFormat.html)

```
// 最常用的格式
yyyy-MM-dd HH:mm:ss

>> 2022-12-05 14:27:19
```

```
SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss Z");
Date date = new Date();   // java.util.Date
String strDate = sdf.format(date);
```


将字符串解析成日期：
```
String format = "yyyy-MM-dd";  
SimpleDateFormat sdf = new SimpleDateFormat(format);  
Date myBeginDate = sdf.parse(beginDate);  
Date myEndDate = sdf.parse(endDate);
```


# java.io包

## Serializable
一般用在实体类上，因为需要转换为JSON来传输！
联想到[[Java_03_高级特性#对象流]]
[[标准库.内置函数#序列化]]
[[Django-2#序列化器的关键步骤]]

```
@Data  
@TableName("pms_attr")  
public class AttrEntity implements Serializable {}
```
一旦实现了Serializable接口，就能将实例的Field序列化为字节流，从而通过网络传输、或进程之间进行传输。也可以通过反序列化将字节流还原为原来的对象实例。

![[Java_03_高级特性#^80c05e]]

serialVersionUID

默认情况下会将这个对象的所有Field全部序列化，可以使用**transient**  [[Java_01_基础#非访问修饰符 - 关键字]]]标记不需要序列化的字段。
加到Field上，在实现Serializable接口的类中，加该关键字的Field将不被序列化；static也不会被序列化
联想，也可以创建一个DTO（缩小版的Pojo对外暴露）[[软件架构模式#^36b507]]


# 🕙java.time包【时间相关都用它】
jdk的早期版本，和时间相关的类库有：[[#Date类]]、[[#Calendar类]]  这两个都非常难用！

Java 8中引入的time包已经纠正了过去的缺陷，将来我们都用它就行了！LTS
```
├── 
	├── java.time                 # 基础包
	├── java.time.chrono          # 不同日历系统访问
	├── java.time.format          # 格式化和解析功
	├── java.time.temporal        # 底层框架和拓展特性
	├──  java.time.zone           # 识趣支持的类
```

## 本地日期时间：LocalDate、LocalTime、LocalDateTime
### 创建对象
1、static now()  当前时间
```
LocalDate.now();
LocalTime.now();
LocalDateTime.now();
```

2、of()  指定时间
```
LocalDate.of(year, month, dayofMonth);
LocalTime.of(date, time, dayOfMonth, 时， 分， 秒)
```
### 常用方法
#### getXxx()
获取
#### withXxx()
指定
#### plusXxx()
加
#### minusXxx()
减

## 时间戳：Instant
![[#^49ad31]]
### 创建对象
1、now()
```
Instant.now();    # 输出当前时间的时间戳，输出的是toString的格式，但是格林威治时区

Instant.now().atOffset(ZoneOffset.ofHour(8));  # 偏移到东八区
```

2、ofEpochMilli(long milliTime)
```
Instant.ofEpochMilli(long milliTime)
```

### 常用方法
#### toEpochMilli()
获取毫秒数！

## 格式化：DataTimeFormatter
用于格式化和解析！

基本使用示例：
```
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");  
LocalDateTime now = LocalDateTime.now();  

dateTimeFormatter.format(now).sout

>> 2024-08-06 11:38:36
```

TemporalAccessor是上层接口，利用LocalDateTime类的from()，转为LocalDateTime的实例对象！ 
```
//解析  
TemporalAccessor temporalAccessor = dateTimeFormatter.parse("2024-08-06 11:38:36");  
LocalDateTime localDateTime = LocalDateTime.from(temporalAccessor);
```

两个常用的场景：
解析模式：
年     yyyy
月     **MM**    <- 大写
日     dd
时     **HH**    <- 大写
分     mm

1、字符串“日期+时间 = LocalDateTime”解析；2024-08-21-10:31
```
String str1 = "2024-08-21-10:31";  
DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd-HH:mm");  
LocalDateTime dateTime = LocalDateTime.parse(str1,formatter1);
```

2、字符串“日期 = LocalDate ”解析：        2024-08-21
```
String str2 = "2024-08-21";  
DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern("yyyy-MM-dd");  
LocalDate date = LocalDate.parse(str2,formatter2);
```

2、字符串“时间 = LocalTime”解析：        10:31
```
String str = "10:31";  
  
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm");  

LocalTime time = LocalTime.parse(str, formatter);
```


# java.sql包
## Date类
继承自java.util.Date类
主要处理数据库中时间相关的对象

### 构造器
#### new Date(long timeMillis)
sql包下的Date类，只有一个构造方法；
==必须传一个时间戳==，来构造一个Date对象实例！

### 常用方法
##### toString()
sql包下的Date类的toString打印出来的结果，和java.util.Date类里的toString格式不同
2022-06-03
没有显示时分秒，但是是包含的！

# jakarta
javax包 是 Oracle公司维护的，针对Java基础包的拓展！
jarkata包 是 Eclipse公司维护的，基于javax的迭代版（主流用这个了）
[Jakarta EE Platform API](https://jakarta.ee/specifications/platform/9/apidocs/overview-summary)
## servlet包
web项目，导入tomcat依赖的时候，自动导入里servlet-api.jar，就能在项目上用！

### Servlet接口
#### GenericServlet 抽象类
需要重新所有方法。

### http包

#### HttpServlet抽象类
我们所有Servlet自定义类，都继承它！
因为，我们只需要写service()，其他和TCP协议相关的周期方法，HttpServlet都帮我们写好了。舒服


# 第三方常用库
OneDrive-个人/文档/02-学习/Learn_Java_Mosh/java_第三方库_关系图.excalidraw

每一个第三方依赖包，都固定用一个版本，本地maven仓库可以复用起来，不用每次一个项目，就下载一个新版本，完全没必要！不然maven-repo越来越大，
## spring-framework

### beans包
#### BeanUtils
##### copyProperties(A,B)
把A对象的属性，--->  拷贝到B对象的属性中，没有的空着。非常实用（VO）

## 日志
门面日志框架，就是类似于接口，直接提供给开发者调用，使用的！
底层日志实现，就是公司针对门面日志框架的具体实现，我们不需要管它们，我们只需要调用门面就行

| 名称      | Jar包                                                              | 描述                                        | 匹配关系                                                              |     |
| ------- | ----------------------------------------------------------------- | ----------------------------------------- | ----------------------------------------------------------------- | --- |
| jcl     | commons-logging.jar                                               | ==门面日志框架==；<br>*很久没有更新*                   | log4j                                                             | 废弃  |
| slf4j   | slf4j-api.jar                                                     | ==门面日志框架==                                | Logback                                                           |     |
|         |                                                                   |                                           |                                                                   |     |
| jul     | JDK<br>java.util.logging                                          | ==底层日志框架==  <br>*不使用*                     | slf4j -> slf4j-jdk14.jar                                          | 废弃  |
| log4j   | log4j.jar                                                         | ==底层日志框架==  <br>log4j 1.x   <br>*已不再更新维护* | jcl   ->   ??<br>slf4j -> slf4j-log4j12.jar                       | 废弃  |
| log4j2  | log4j-api.jar<br>log4j-core.jar                                   | ==底层日志框架==                                | slf4j -> log4j-slf4j-impl.jar<br>slf4j <= 1.7.x适用<br>（我固定用1.7.22） |     |
| Logback | logback-classic.jar<br>~~logback-core.jar~~<br>(不用导，在classic中包含了) | ==底层日志框架==                                | slf4j                                                             |     |

Slf4j，酸辣粉四斤！
Slf4j 是日志的顶层接口，所有实现类的规范
下属的实现类有：
	log4j
	log4j2
	logback

![](https://picgo-rockyshen.oss-cn-shanghai.aliyuncs.com/picgo/202407281131818.png)

### 基本概念
#### Logger
记录器，日志类别和级别；

五个日志级别：DEBUG、INFO、WARN、ERROR和FATAL

只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。
#### Appender
输出源：日志要输出的地方；
- org.apache.log4j.ConsoleAppender（控制台）
- org.apache.log4j.FileAppender（文件）
- org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
- org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
- org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
#### Layout
布局：日志以何种形式输出。
- org.apache.log4j.HTMLLayout（以HTML表格形式布局）
- org.apache.log4j.PatternLayout（可以灵活地指定布局模式）
- org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）
- org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）


[tailspin](https://github/com/bensadeh/tailspin)：github开源项目，高亮阅读日志！

### ~~[[#【日志门面】apache.commons.logging包]]~~
org.apache.commons.logging

### 【日志门面】slf4j
org.slf4j

有人对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。
	例如拼接字符串等，而不是占位符

固定使用这个依赖，maven本地仓库中有
```
<dependency>  
    <groupId>org.slf4j</groupId>  
    <artifactId>slf4j-api</artifactId>  
    <version>1.7.22</version>  
</dependency>
```

^be6109

SpringBoot框架使用Slf4JLoggingSystem实现此规范。
在org.springframework.boot.context.logging包下

### ~~【日志实现】log4j 1.x~~
apache的一个开源项目。==太老了，废弃！==

既有针对  -->  ~~[[#【日志门面】apache.commons.logging包]] 的实现，这个一般都不用了！~~
也有正对  -->  [[#【日志门面】slf4j]] 的实现，一般这个用的比较多！

slf4j的包里，默认就带了log4j（一代）的支持，只需要导入下面的依赖，就能直接用log4j了
注意：不要换版本，本地maven仓库中已经存在了，避免复用！

方式1： slf4j提供绑定器,它将slf4j API 的调用转发到 Log4j 1.2 的实现上
```
<dependency>  
    <groupId>org.slf4j</groupId>  
    <artifactId>slf4j-log4j12</artifactId>  
    <version>1.7.28</version>  
</dependency>
```

方式2：（不推荐）直接使用Log4j 1.2 的 API，没有依赖日志门面，不是一个规范的操作
与实现紧耦合,降低了代码的可移植性。
```
<dependency>
   <groupId>log4j</groupId>
   <artifactId>log4j</artifactId>
   <version>1.2.15</version>
</dependency>
```
#### log4j的配置文件
都是放在resources文件夹下：
（输出到IDEA的文件模版中，直接右键创建模版即可）

方式1：log4j.properties
```
log4j.rootLogger=DEBUG,stdout  
log4j.logger.org.mybatis=DUBUG  
log4j.appender.stdout=org.apache.log4j.ConsoleAppender  
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  
log4j.appender.logDailyFile.layout.ConversionPattern = %5p %d %C:%m%n
```

一个较为标准的参考配置
```
# 输出到控制台

# WARN：日志级别  CONSOLE：输出位置自己定义的一个名字 logfile：输出位置自己定义的一个名字
log4j.rootLogger=WARN,CONSOLE,logfile
# 配置CONSOLE输出到控制台
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender 
# 配置CONSOLE设置为自定义布局模式
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout 
# 配置CONSOLE日志的输出格式  [frame] 2019-08-22 22:52:12,000  %r耗费毫秒数 %p日志的优先级 %t线程名 %C所属类名通常为全类名 %L代码中的行号 %x线程相关联的NDC %m日志 %n换行
log4j.appender.CONSOLE.layout.ConversionPattern=[frame] %d{yyyy-MM-dd HH:mm:ss,SSS} - %-4r %-5p [%t] %C:%L %x - %m%n

# 输出到日志文件中
# 配置logfile输出到文件中 文件大小到达指定尺寸的时候产生新的日志文件
log4j.appender.logfile=org.apache.log4j.RollingFileAppender
# 保存编码格式
log4j.appender.logfile.Encoding=UTF-8
# 输出文件位置此为项目根目录下的logs文件夹中
log4j.appender.logfile.File=logs/root.log
# 后缀可以是KB,MB,GB达到该大小后创建新的日志文件
log4j.appender.logfile.MaxFileSize=10MB
# 设置滚定文件的最大值3 指可以产生root.log.1、root.log.2、root.log.3和root.log四个日志文件
log4j.appender.logfile.MaxBackupIndex=3  
# 配置logfile为自定义布局模式
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %F %p %m%n

# 对不同的类输出不同的日志文件
# club.bagedate包下的日志单独输出
log4j.logger.club.bagedate=DEBUG,bagedate
# 设置为false该日志信息就不会加入到rootLogger中了
log4j.additivity.club.bagedate=false

# 下面就和上面配置一样了
log4j.appender.bagedate=org.apache.log4j.RollingFileAppender
log4j.appender.bagedate.Encoding=UTF-8
log4j.appender.bagedate.File=logs/bagedate.log
log4j.appender.bagedate.MaxFileSize=10MB
log4j.appender.bagedate.MaxBackupIndex=3
log4j.appender.bagedate.layout=org.apache.log4j.PatternLayout
log4j.appender.bagedate.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %F %p %m%n
```

腾讯云上的参考配置
```
### set log levels 
### log4j.rootLogger = DEBUG , C , D , E 

### console ### 
log4j.appender.C = org.apache.log4j.ConsoleAppender 
log4j.appender.C.Target = System.out 
log4j.appender.C.layout = org.apache.log4j.PatternLayout log4j.appender.C.layout.ConversionPattern = [mybatis_study][%p] [%-d{yyyy-MM-dd HH\:mm\:ss}] %C.%M(%L) | %m%n 

### log file ### 
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender 
log4j.appender.D.File = ../logs/mybatis_study.log log4j.appender.D.Append = true log4j.appender.D.Threshold = INFO 
log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern = [mybatis_study][%p] [%-d{yyyy-MM-dd HH\:mm\:ss}] %C.%M(%L) | %m%n 

### exception ### 
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender 
log4j.appender.E.File = ../logs/mybatis_study_error.log 
log4j.appender.E.Append = true 
log4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayout 
log4j.appender.E.layout.ConversionPattern = [mybatis_study][%p] [%-d{yyyy-MM-dd HH\:mm\:ss}] %C.%M(%L) | %m%n 

### mybatis show sql ### 
log4j.logger.com.ibatis=debug log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug log4j.logger.java.sql.Connection=debug log4j.logger.java.sql.Statement=debug log4j.logger.java.sql.PreparedStatement=debug
```


方式2：log4j.xml  不常用！

### 【日志实现】Logback
基于[[#【日志门面】slf4j]] 的实现；Springboot默认使用此

log4j 2.x 是Apache官方出的2.0版本； Logback是源代码作者自己出的2.0版本
以下是来自官网的原话，这是由log4j源代码作者，独立开发的另一个项目，被称为：log4j后浪
```
Logback 旨在作为流行的 log4j 项目的继承者，继承 log4j 1.x 所遗漏的内容。
```

Logback需要搭配slf4j一起使用。
	slf4j作为门面框架，底层用logback

固定使用这个依赖，版本也是验证过的，直接拷贝用！maven本地仓库中有
![[#^be6109]]
```
<dependency>  
    <groupId>ch.qos.logback</groupId>  
    <artifactId>logback-classic</artifactId>  
    <version>1.2.3</version>  
</dependency>
```
logback-core可以不用导入，因为logback-classic已经包含了！

#### Logback的配置文件
![[SpringBoot#^c0dd59]]

logback-spring.xml（输出到IDEA的文件模版中，直接右键创建模版即可）
```
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 定义日志文件的存储地址和文件名 -->
    <property name="LOG_PATH" value="./logs" />
    <property name="LOG_FILE_NAME" value="my-application.log" />

    <!-- appender1 用于控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- appender2  用于以文件输出（按天滚动） -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${LOG_FILE_NAME}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/%d{yyyy-MM-dd}/${LOG_FILE_NAME}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>50MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        
    </appender>

    <!-- 根 Logger 配置 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>

    <!-- 特定包的 Logger 配置 -->
    <logger name="com.example.myapp" level="DEBUG" />
</configuration>
```

### 【日志实现】log4j 2.x
log4j 2.x 是Apache官方出的2.0版本； Logback是源代码作者自己出的2.0版本
有一段恩怨！

![[SpringBoot#^54c984]]

这是非Spring项目，单独引入log4j2的依赖，示例
可以看到版本是 v2.x.x
```
<dependencies>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-api</artifactId>
        <version>2.17.1</version>
    </dependency>

    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.17.1</version>
    </dependency>

    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-slf4j-impl</artifactId>
        <version>2.17.1</version>
    </dependency>
</dependencies>
```


## lombak
Java中最常用的好伙伴

固定一个版本的依赖包，所有项目都复用！
```
<dependency>
   <groupId>org.projectlombok</groupId>
   <artifactId>lombok</artifactId>
   <version>1.18.34</version>
</dependency>
```
### 常用lombak注解

| XX                       | XX                                                      |
| ------------------------ | ------------------------------------------------------- |
| @Data                    | 自动添加Getter Setter toString方法<br>![[Java_01_基础#^c62eaf]] |
| [[#@slf4j]]              | 日志相关，自动注入log对象                                          |
| @AllArgsConsrtructor     | 全参构造器                                                   |
| @NoArgsConstructor       | 无参构造器                                                   |
| @RequiredArgsConstructor | 为类中final和non-null字段作为构造函数的参数                            |
| @Accessors(chain=true)   | 开启链式调用，一种新的语法现象                                         |

RequiredArgsConstructor注解的示例
```
@RequiredArgsConstructor
public class MyClass{
	private final String requiredField1;
	private final int requiredField2;
	private String optionalField;
}

	// 加了注解，就不要写构造函数了！
	public MyClass(String requiredField1, int requiredField2){
		this.requiredField1 = requiredField1;
		this.requiredField2 = requiredField2
	}
```

2024.9.18 我在gulimall的项目中，发现lombak的@Data失效，根本没有给我生成getter和setter方法！怎么解决？

### @slf4j
@Slf4j 是[[#lombak]]整合的注解（加到类上）；自动注入private static final Logger，直接获取log对象就能使用！
利用@Slf4j注解，注入一个log对象，示例 ^8df9b7

必须加入这两个依赖
```
<dependency>  
    <groupId>org.projectlombok</groupId>  
    <artifactId>lombok</artifactId>  
    <version>1.18.34</version>  
</dependency>  
<dependency>  
    <groupId>org.slf4j</groupId>  
    <artifactId>slf4j-api</artifactId>  
    <version>2.0.0</version>  
</dependency>
```

```
@Slf4j
public class Demo {
	public static void main(String[] args) {
		String msg = "Hello World.";
		log.info("This is a test message:{}", message);
	}
}

```

^a5de22

#### 常见配置
这里记录@Slf4j的常用配置
```

```

## Jackson
Jackson是Java原生的解析JSON的库

Java中处理JSON数据变得更加简单和高效。通过ObjectMapper，开发人员可以轻松地在Java对象和JSON数据之间进行转换，这在实际的应用程序中是非常常见的需求。

[[#Serializable]]
当你在Spring MVC中使用@ResponseBody注解时，Spring MVC会默认使用Jackson库来将返回的对象转换为JSON格式，而Jackson库会在运行时动态地访问对象的属性，并将其转换为JSON格式的数据。因此，即使你的实体类没有显式地实现Serializable接口，Spring MVC仍然能够将其转换为JSON并返回给客户端。

ObjectMapper类的主要功能包括：
1. 将Java对象转换为JSON格式的字符串（序列化）

2. 将JSON格式的字符串转换为Java对象（反序列化）

3. 处理JSON树状结构（JsonNode），以便于对JSON数据进行操作和处理

4. 提供各种配置选项，例如日期格式、处理 null 值、处理不确定的字段等

![[JavaWeb#^a733e5]]

@JsonFormat()
	pattern = "yyyy-MM-dd HH:mm:ss",
	timezone = "GMT+8"

@DateTimeFormat()
	pattern = "yyyy-MM-dd HH:mm:ss"
加到时间相关字段上。

在SpringBoot的yaml中全局指定
```
spring:
	jackson:
		date-format: yyyy-MM-dd HH:mm:ss
		time-zone: GMT+8
```

## FastJson
阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。

Spring框架官方的JSON解析器是[[#Jackson]]

依赖引入，固定用这个版本，不然maven-repo越来越大！
```
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.83</version>
</dependency>
```

## gson
Google提供的JSON解析工具包

固定用这个版本的依赖，本地仓库已经下载了！
```
<dependency>
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson</artifactId>
   <version>2.9.1</version>
</dependency>
```
## junit5
单元测试框架！
这里容易导错包，一定要注意对应关系

| XX             | XX                         |                                             |
| -------------- | -------------------------- | ------------------------------------------- |
| Junit4         | org.junit.Test             | Spring Boot 2.2.x之前用4<br>必须配合@RunWith注解一起使用 |
| Junit5 ^28cb08 | org.junit.jupiter.api.Test | Spring Boot 2.2.x之后用5                       |

### junit5
junit5的依赖，固定用这个版本，不然maven-repo越来越大！
```
<dependency>
   <groupId>org.junit.jupiter</groupId>
   <artifactId>junit-jupiter-api</artifactId>
   <version>5.10.0</version>
</dependency>
```

```
@SpringBootTest
public class JwtTest {
    // Field，依赖注入
    @Autowired
    private JwtHelper jwtHelper;

    @Test
    public void test01(){}

```

Junit5使用示例代码

main/java中写完的类和方法，在类名上右键，create test，可以基于Junit 5自动到test/java下生成测试方法！进行单元测试。

使用断言方法，来验证方法是否正确！

![[命名规范#^fead05]]
#### 常用方法
@Test    标注为测试方法
@AfterAll   在测试方法执行之后执行，静态，只执行一次（例如关闭资源）
@BeforeAll  在测试方法执行之前执行，静态，只执行一次（例如加载数据库连接池）
@AfterEach   在测试方法执行之后执行，执行多次
@BeforeEach   在测试方法执行之前执行，执行多次
##### Assertions
断言工具类，提供各种静态断言方法

###### assertEquals / assertNotEquals()
断言是否相等
```
Assertions.assertEquals(num, 10);    //测试结果num，如果等于10，就测试通过
```
###### assertNull / assertNotNull
断言是否为空


```
<!--        springboot与junit整合的测试场景启动器-->  
<dependency>  
	<groupId>org.springframework.boot</groupId>  
	<artifactId>spring-boot-starter-test</artifactId>  
</dependency>
```

如何在最普通的IDEA项目中，引入Junit库？
[[Java_01_基础#导Jar包/库]]

JUnit单元测试，比main方法中有哪些好处？
1、main方法里，如果只想执行一部分，需要把前面的代码注释掉。JUnit单元测试的话，就不需要，直接多个方法@Test，独立执行
2、main方法是静态方法，里面要想用同一个类中的方法，需要实例化之后再调用；如果是JUnit单元测试类，由于是非静态类，直接调用方法即可。

```
public class TestJUint{
	public void method(){
		sout("method.....");
	}

	public static void main(String[] args){
		TestJUnit testJUnit = new TestJUnit();
		testJUnit.method();
	}

	@Test
	public void test01(){
		method();           //对比静态方法main，还要实例化，这里直接调用即可！
	}
}
```

### ~~Junit4~~
**放弃，不用这个了！**
Junit4使用示例代码
```
@RunWith(SpringRunner.class)         // JUnit4需要
@SpringBootTest
public class GulimallProductApplicationTests {
    @Autowired
    BrandService brandService;

	@Test
    public void testFindPath(){
		// 测试方法
    }
}
```

## hutool
https://doc.hutool.cn/pages/index/

依赖包，固定用这个版本，不然maven-repo越来越大
```
<dependency>  
    <groupId>cn.hutool</groupId>  
    <artifactId>hutool-all</artifactId>  
    <version>5.8.8</version>  
</dependency>
```

Java的一个工具包，
具体来说，Hutool提供了如下功能：  
- 字符串处理：包括字符串判空、截取、替换等操作  
- 日期时间处理：提供了方便的日期时间操作以及格式化方法  
- 文件操作：简化了文件读写、复制、文件类型判断等操作  
- 加密解密：支持常见的加密算法、摘要算法以及Base64编解码  
- HTTP请求：提供了简洁易用的Http请求工具  
- 数据校验：包括身份证校验、手机号校验、邮箱校验等  
- 对象转换：方便地进行Bean对象与Map、JSON等数据结构之间的转换  
  
总的来说，Hutool旨在提高Java开发效率，简化开发人员的日常工作，使得开发过程更加便捷。如果你在Java项目中需要频繁使用各种工具方法，可以考虑引入Hutool来简化开发工作。

### 字符串相关

#### StrUtil
提供：[[#apache.commons.lang3包]]中[[#StringUtils类]]相同的功能

联想到：[[SpringMVC#参数校验]]   ->  @NotNull    @NotEmpty    @NotBlank

##### 常用方法


###### hasBlank(str1, str2)
传递的多个字符串对象，是否为空或包含空白格！

常用来在Controller层，传递来的参数进行判空！
###### hasEmpty(str1, str2)
传递的多个字符串对象，是否为空

### core.util包
#### RandomUtil类
```
map.put("nonce", RandomUtil.randomNumbers(4));  //参数3:随机数

// 随机数工具  
int randomInt = RandomUtil.randomInt(1, 100);  
System.out.println("随机整数：" + randomInt);
```

#### StrUtil类
```
// 字符串工具  
String str = "Hutool is awesome";  
boolean isEmpty = StrUtil.isEmpty(str);  
System.out.println("字符串是否为空：" + isEmpty);
```

#### NumberUtil类
```
// 数字工具  
double result = NumberUtil.add(1.2, 3.4);  
System.out.println("数字相加：" + result);
```

### core.io包
FileUtil类
```
public class FileExample {  
    public static void main(String[] args) {  
        // 读取文件内容  
        String content = FileUtil.readUtf8String("test.txt");  
        System.out.println("文件内容：" + content);  
  
        // 写入文件内容  
        FileUtil.writeUtf8String("Hello, Hutool!", "test.txt");  
  
        // 复制文件  
        FileUtil.copy("test.txt", "test_copy.txt", true);  
    }  
}
```

### http包
类似于：
- 原生的HttpClient 
- [[Spring FrameWork#~~RestTemplate~~]]
- [[JavaWeb#【实现类】HttpServletRequest]]

#### HttpRequest
发起HTTP请求的类，获取到HttpResponse响应对象
```
HttpResponse httpResponse = HttpRequest.post("http://localhost:8123/api/name/user")  
        .addHeaders(getHeadMap(json))  // 将map作为参数，传递到header中
        .body(json)  
        .execute();
```

```
import cn.hutool.http.HttpRequest;  
import cn.hutool.http.HttpResponse;  
  
public class HttpExample {  
    public static void main(String[] args) {  
        // 发送 GET 请求  
        HttpResponse response = HttpRequest.get("https://api.github.com")  
                .timeout(2000)  // 超时设置，单位毫秒  
                .execute();  
        System.out.println("响应内容：" + response.body());  
  
        // 发送 POST 请求  
        HttpResponse postResponse = HttpRequest.post("https://httpbin.org/post")  
                .form("key1", "value1")  
                .timeout(2000)  
                .execute();  
        System.out.println("POST 响应内容：" + postResponse.body());  
    }  
}
```

### crypto.digest包
##### Digester(加密算法)
利用加密算法，生成加密字符串。
![[加密#^9d05d8]]

```
import cn.hutool.crypto.SecureUtil;  
import cn.hutool.crypto.symmetric.AES;  
  
public class CryptoExample {  
    public static void main(String[] args) {  
        // MD5 加密  
        String md5 = SecureUtil.md5("password");  
        System.out.println("MD5：" + md5);  
  
        // AES 加密解密  
        AES aes = SecureUtil.aes();  
        String encrypted = aes.encryptHex("Hello, Hutool!");  
        System.out.println("AES 加密：" + encrypted);  
        String decrypted = aes.decryptStr(encrypted);  
        System.out.println("AES 解密：" + decrypted);  
    }  
}
```

### json包
#### JsonUtil
##### 常用方法
###### toJsonStr(User user)
将对象转换为Json字符串
```
@Data
public User user {
	public String name;
	public Integer age;
}

User tom = new User("tom",28);

|
V

{
  "name": "tom",
  "age": 28
}
```

```
public String getUserNameByPost(User user) {  
	String json = JSONUtil.toJsonStr(user);  
//        System.out.println(json);  
	HttpResponse httpResponse = HttpRequest.post(GATEWAY_HOST + "/api/name/user")  
			.addHeaders(getHeadMap(json))  
			.body(json)  
			.execute();  
	System.out.println(httpResponse.getStatus());  
	String result = httpResponse.body();  
	return result;  
}
```

### data包
处理日期！
```
import cn.hutool.core.date.DateUtil;  
  
public class DateExample {  
    public static void main(String[] args) {  
        // 获取当前时间  
        Date now = DateUtil.date();  
        System.out.println("当前时间：" + now);  
  
        // 字符串转日期  
        String dateStr = "2022-01-01 12:30:45";  
        Date date = DateUtil.parse(dateStr);  
        System.out.println("字符串转日期：" + date);  
  
        // 日期格式化  
        String format = DateUtil.format(date, "yyyy/MM/dd");  
        System.out.println("日期格式化：" + format);  
  
        // 日期加减  
        Date newDate = DateUtil.offsetDay(now, -3);  
        System.out.println("三天前的时间：" + newDate);  
    }  
}
```

## apache.commons
提供了一系列工具集合类，类似于[[#hutool]]

### apache.commons.lang3包
依赖包就用这个版本，本地Maven库就有，避免重复下载。
```
<dependency>  
    <groupId>org.apache.commons</groupId>  
    <artifactId>commons-lang3</artifactId>  
    <version>3.13.0</version>  
</dependency>
```

1. 字符串操作：commons-lang3 提供了一系列字符串处理的工具方法，如字符串拼接、截取、替换、比较、分割、格式化等。
2. 对象操作：commons-lang3 提供了一些用于对象的工具方法，如对象比较、克隆、深拷贝等。
3. 数组操作：commons-lang3 提供了一些用于数组的工具方法，如数组转换、复制、填充、合并、查找、截取等。
4. 日期操作：commons-lang3 提供了一些用于日期和时间的工具方法，如日期格式化、解析、计算等。
5. 异常处理：commons-lang3 提供了一些用于异常处理的工具方法，如异常封装、转换、堆栈信息获取等。

#### StringUtils类
org.apache.commons.lang3.StringUtils
提供了字符串处理的工具方法，如判断字符串是否为空、截取子串、拼接字符串等。

empty  =>  null  或 str.length()=0
	    不为空    不等于null      ^028e43

blank    => null  或 str.length()=0  或  空白格

| XX                     | 含义          | 反例示范                            |
| ---------------------- | ----------- | ------------------------------- |
| isEmpty(str)           | 是否为空        | isEmpty("   ")    空白格不作为empty处理 |
| isBlank(str)           | 是否为空或有空白格   |                                 |
| isNotBlank(str)        | 是否不为空或没有空白格 |                                 |
| isAnyBlank(str1, str2) | 多个字符串中，满足任一 |                                 |

^7ac796

###### static boolean isEmpty(str)
检查字符串是否为空，包括 null 和空字符串。

注意区分：Object类的通用方法[[#boolean isEmpty()]]
![[#^21ee45]]

###### static boolean isBlank(str)
检查字符串是否为空或仅包含空白字符。
###### isAnyBlank(str)
检查传入的多个字符串参数中是否有任何一个是 null 或者空字符串或者只包含空白字符
```
String str1 = "hello";
String str2 = "";
String str3 = "  ";
String str4 = null;

boolean anyBlank = StringUtils.isAnyBlank(str1, str2, str3, str4);
System.out.println(anyBlank);  // 输出 true
```
###### isNotBlank()
```
if (StringUtils.isNotBlank(name)) {
	queryWrapper.eq("name",name);
}
```


常规的String操作方法，类似：[[#String类]]
trim()   去除字符串两端的空白字符

#### Pair类
org.apache.commons.lang3.tuple
注意：apache.commons包提供Pair是抽象类，不能被直接实例化
实例化时可以使用MutablePair和ImmutablePair，一个可变，一个不可变
1、key一旦设定了，不管是MutablePair 还是 ImmutablePair都是不能改的！
2、immutablePair不可变，是指setValue时，会报错：java.lang.UnsupportedOperationException
```
ImmutablePair<String,Integer> immutablePair = new ImmutablePair("a",1);  
immutablePair.setValue(2);              // 不可变，即无法设置值
  
MutablePair<String,Integer> mutablePair = new MutablePair<>("b",2);  
mutablePair.setValue(3);               // 可以设置值  
```

### ~~【日志门面】apache.commons.logging包~~
org.apache.commons.logging包
apache.commons.lang3.logging包的特点就是：它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。

maven依赖
```
<dependency>
  <groupId>commons-logging</groupId>
  <artifactId>commons-logging</artifactId>
  <version>1.2</version>
</dependency>
```
#### Log
org.apache.commons.logging.Log
#### LogFactory

注意：这是不是apache，是一个第三方包，所以可以看到maven依赖的groupId中没有apache，所以需要单独导入。

## EasyExcel
与poi对比

依赖包，固定用这个版本，不然maven-repo越来越大
```
<dependency>  
    <groupId>com.alibaba</groupId>  
    <artifactId>easyexcel</artifactId>  
    <version>3.3.4</version>  
</dependency>
```

| EasyExcel | poi        |
| --------- | ---------- |
| 逐行加载到内存中  | 一次性加载到内存中  |
| 查方便       | 添加、修改、删除方便 |
| 联想到：数组    | 联想到：链表     |

[EasyExcel操作手册](https://easyexcel.opensource.alibaba.com/docs/current/)

**写操作的步骤**
1、引入依赖
2、创建实体类（和Excel的column对应），设置excel表头
```
@Data
public class User{
	@ExcelProperty(value="用户编号")
	private int id;

	@ExcelProperty(value="用户名称")
	private String name;

}
```
3、调用EasyExcel方法实现写操作。
```
public class TestWrite {
	String fileName = "D:\\atguigu.xlsx";
	EasyExcel.write(fileName,User.class)
			 .sheet("表1")
			 .doWrite(data());
}

	private static List<User> data(){
		List<User> list = new ArrayList<User>();
		for (int i = 0, i < 10, i++){
			User data = new User();
			data.setId(i);
			data.setName("lucy"+i);
			list.add(data);
		}
		return list
	}
```

3、课程分类导入（将excel添加到数据库表）

**读操作的步骤**
1、引入依赖
2、创建与Excel对应实体类，设置对象关系
```
@Data
public class User{
	@ExcelProperty(value="用户编号", index=0)
	private int id;

	@ExcelProperty(value="用户名称", index=1)
	private String name;

}
```

3、创建监听器，进行逐行解析过程
	（1）创建类，继承类，封装解析方法
```
public class ExcelListener extends AnalysisEventListener<User> {
    //创建list集合封装最终的数据
    List<User> list = new ArrayList<User>();
    
    //一行一行去读取excle内容
    @Override
    public void invoke(User user, AnalysisContext analysisContext) {
        System.out.println("***"+user);
        list.add(user);
    }
    
    //读取excel表头信息
    @Override
    public void invokeHeadMap(Map<Integer, String> headMap, AnalysisContext context) {
        System.out.println("表头信息："+headMap);
    }
    //读取完成后执行
    @Override
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {
    }
}
```

4、调用EasyExcel读方法实现操作
```
   public static void main(String[] args) throws Exception {
        String fileName = "D:\\atguigu.xlsx";
        
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        EasyExcel.read(fileName, User.class, new ExcelListener()).sheet().doRead();
}
```

## Guava
google提供给Java的工具库，提供了许多常用的工具类和数据结构，例如集合、缓存、并发工具等，是许多Java开发者的首选库之一。
[一篇让你熟练掌握Google Guava](https://juejin.cn/post/6964267379547504648)

maven依赖，本地repo就有，就用这个，避免复用。
```
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>22.0</version>
</dependency>
```

### 布隆过滤器
#### 创建bloomFilter
```
BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);

// Funnels.integerFunnel() 固定写法
// size表示bitMap数组的长度
// fpp表示误差概率，误差概率越小，需要介入的hash函数越多，性能越差！
```

#### bloomFilter.put(value)
将value通过hash计算，放入bitMap的某个位置上，设置为true

#### boolean mightContain(value)
判断传入的value，是否在bitMap中存在！

## Redisson
是官方推荐的Java版Redis客户端
方便开发者在Java应用程序中连接和操作Redis数据库。

依赖包，固定用这个版本，在本地仓库已有！
```
<dependency>
  <groupId>org.redisson</groupId>
  <artifactId>redisson</artifactId>
  <version>3.15.0</version>
</dependency>
```

[[SpringBoot#Redisson的SpringBoot配置]]

### 基本步骤

#### 步骤1：基于config，连接redis
```
Config config = new Config();

config.useSingleServer()
      .setAddress("redis://127.0.0.1:6379")
      .setPassword("your_password");

RedissonClient client = Redisson.create(config);
```

#### 步骤2：基于client，进行常规redis操作
```
RBucket<String> bucket = client.getBucket("myKey");
// 获取字符串值
bucket.set("Hello, Redison!");
String value = bucket.get();
System.out.println(value);

// 操作Set集合
RSet<String> set = client.getSet("mySet");
set.add("item1");
set.add("item2");
set.add("item3");
System.out.println(set.size());
```


例如可以：使用分布式锁
```
// 获取分布式锁
RLock lock = client.getLock("myLock");

lock.lock();
try {
  // 在这里执行需要同步的代码
} finally {
  lock.unlock();    // 删除key,必须保证原子性，采用lua脚本
}
```

^a9cb3a

#### 步骤3：关闭连接
```
client.shutdown();
```

### 常用方法
#### getBitSet()

#### getLock(lockKey)

#### 布隆过滤器
##### getBloomFilter()
布隆过滤器
##### bloomFilter.tryInit(500000L,0.03)
bitmap数组的容量，50W个位置；误差率是3%

##### bloomFilter.add(String value)
将这个值加入布隆过滤器，底层会基于value，计算出数组的偏移量（有多个hash函数计算出多个偏移位置，这几个偏移位置设置成1）

##### bloomFilter.contains(String value)
返回bitMap中是否包含此值！

#### 其他
##### toJSONString(obj)
将对象转换成 JSON 字符串
```
String text = JSON.toJSONString(obj); //序列化
```
##### parseObject(json, 对象.class)
将 JSON 字符串转换成对象。
```
VO vo = JSON.parseObject("{...}", VO.class); //反序列化
```


```
public class Person {
    @JSONField(name = "AGE")   // 注解方式
    private int age;
 
    @JSONField(name = "FULL NAME")
    private String fullName;
 
    @JSONField(name = "DATE OF BIRTH")
    private Date dateOfBirth;
 
    public Person(int age, String fullName, Date dateOfBirth) {
        super();
        this.age = age;
        this.fullName= fullName;
        this.dateOfBirth = dateOfBirth;
    }
 
    // 标准 getters & setters
}
```

还可以自定义format，输出的JSON中符合要求的格式
```
@JSONField(name="DATE OF BIRTH", format="dd/MM/yyyy", ordinal = 3)  
private Date dateOfBirth;

>>输出
>> "DATE OF BIRTH":"19/07/2016"
```


```
private List<Person> listOfPersons = new ArrayList<Person>();
 
@Before
public void setUp() {
    listOfPersons.add(new Person(15, "John Doe", new Date()));
    listOfPersons.add(new Person(20, "Janette Doe", new Date()));
}
 
@Test
public void whenJavaList_thanConvertToJsonCorrect() {
    String jsonOutput= JSON.toJSONString(listOfPersons);
}

输出成JSON格式

[  
    {  
        "AGE":15,
        "DATE OF BIRTH":1468962431394,
        "FULL NAME":"John Doe"
    },
    {  
        "AGE":20,
        "DATE OF BIRTH":1468962431394,
        "FULL NAME":"Janette Doe"
    }
]
```

## Jedis
Java直接操作Redis的原生客户端，通过直接操作Redis协议，来与Redis通信。
感觉Jedis更直观，Redisson更加复杂！

maven依赖，就固定用这个依赖，本地maven-repo就有，不要重复下载各种不同版本了！
```
<dependency>  
	<groupId>redis.clients</groupId>  
	<artifactId>jedis</artifactId>  
	<version>3.8.0</version>  
</dependency>
```
### 常用方法

#### 构造方法 jedis(url, port)
```
Jedis jedis = new Jedis("47.101.200.22",6379);   // 获取到jedis实例，就可以操控redis数据库了！
```

#### Bitmap相关
##### setbit(key, offset, value)
key是键，offset是利用哈希函数计算出来的数组偏移量，value是true或false!

##### getbit(key, hash(value))
在该key对应的bitmap中，根据偏移量查询到这个值是0还是1，是true还是false

#### 关闭资源
##### close()
关闭redis连接！
